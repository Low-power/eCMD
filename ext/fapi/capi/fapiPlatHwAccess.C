/* The following has been auto-generated by makedll.pl */

#include <stdio.h>

#include <ecmdClientCapi.H>
#include <ecmdSharedUtils.H>
#include <ecmdClientEnums.H>
#include <fapiClientCapi.H>

#include <fapiHwAccess.H> 
#include <fapiSharedUtils.H> 
#ifndef ECMD_STATIC_FUNCTIONS
#include <fapiClientEnums.H>
#include <fapiTarget.H>
#endif

#include <fapiDllCapi.H>
#include <ecmdDllCapi.H>

#include <ecmdUtils.H>

static const char ECMD_DLL_NOT_LOADED_ERROR[] = ": eCMD Function called before DLL has been loaded\n";
static const char ECMD_UNABLE_TO_FIND_FUNCTION_ERROR[] = ": Unable to find function, must be an invalid DLL - program aborting\n";

using namespace fapi;

#ifndef ECMD_STATIC_FUNCTIONS

 #include <dlfcn.h>

/* This is from ecmdClientCapiFunc.C */
 extern void * dlHandle;
 extern void * DllFnTable[];

 void * fapiDllFnTable[FAPI_NUMFUNCTIONS];

#else

 #include <fapiDllCapi.H>

#endif


/* Our initialization flag */
 bool fapiInitialized = false;
#ifndef ECMD_STRIP_DEBUG
extern int ecmdClientDebug;
extern int fppCallCount;
extern bool ecmdDebugOutput;
#endif

#if 0
ReturnCode fapiGetRing(const Target& i_handle, const uint32_t i_address, ecmdDataBufferBase & o_data) {

  ReturnCode rc;

#ifndef ECMD_STATIC_FUNCTIONS
  if (dlHandle == NULL) {
    fprintf(stderr,"dllFapiGetRing%s",ECMD_DLL_NOT_LOADED_ERROR);
    exit(ECMD_DLL_INVALID);
  }
#endif

  if (!fapiInitialized) {
    fprintf(stderr,"dllFapiGetRing: eCMD Extension not initialized before function called\n");
    fprintf(stderr,"dllFapiGetRing: OR eCMD fapi Extension not supported by plugin\n");
    exit(ECMD_DLL_INVALID);
  }

#ifndef ECMD_STRIP_DEBUG
  int myTcount;
  std::vector< void * > args;
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &i_handle);
     args.push_back((void*) &i_address);
     args.push_back((void*) &o_data);
     fppCallCount++;
     myTcount = fppCallCount;
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONIN,"ReturnCode fapi::GetRing(const Target& i_handle, const uint32_t i_address, ecmdDataBufferBase & o_data)",args);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONIN,"fapi::GetRing");
  }
#endif

#ifdef ECMD_STATIC_FUNCTIONS
  rc = dllFapiGetRing(i_handle, i_address, o_data);
#else
  if (fapiDllFnTable[ECMD_FAPIGETRING] == NULL) {
     fapiDllFnTable[ECMD_FAPIGETRING] = (void*)dlsym(dlHandle, "dllFapiGetRing");
     if (fapiDllFnTable[ECMD_FAPIGETRING] == NULL) {
       fprintf(stderr,"dllFapiGetRing%s",ECMD_UNABLE_TO_FIND_FUNCTION_ERROR); 
       ecmdDisplayDllInfo();
       exit(ECMD_DLL_INVALID);
     }
  }

  ReturnCode (*Function)(const Target&,  const uint32_t,  ecmdDataBufferBase &) = 
      (ReturnCode(*)(const Target&,  const uint32_t,  ecmdDataBufferBase &))fapiDllFnTable[ECMD_FAPIGETRING];
  rc =    (*Function)(i_handle, i_address, o_data);
#endif

#ifndef ECMD_STRIP_DEBUG
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &rc);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONOUT,"fapi::GetRing");
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONOUT,"ReturnCode fapi::GetRing(const Target& i_handle, const uint32_t i_address, ecmdDataBufferBase & o_data)",args);
   }
#endif

  return rc;
}

ReturnCode fapiPutRing(const Target& i_handle, const uint32_t i_address, ecmdDataBufferBase & i_data) {

  ReturnCode rc;

#ifndef ECMD_STATIC_FUNCTIONS
  if (dlHandle == NULL) {
    fprintf(stderr,"dllFapiPutRing%s",ECMD_DLL_NOT_LOADED_ERROR);
    exit(ECMD_DLL_INVALID);
  }
#endif

  if (!fapiInitialized) {
    fprintf(stderr,"dllFapiPutRing: eCMD Extension not initialized before function called\n");
    fprintf(stderr,"dllFapiPutRing: OR eCMD fapi Extension not supported by plugin\n");
    exit(ECMD_DLL_INVALID);
  }

#ifndef ECMD_STRIP_DEBUG
  int myTcount;
  std::vector< void * > args;
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &i_handle);
     args.push_back((void*) &i_address);
     args.push_back((void*) &i_data);
     fppCallCount++;
     myTcount = fppCallCount;
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONIN,"ReturnCode fapi::PutRing(const Target& i_handle, const uint32_t i_address, ecmdDataBufferBase & i_data)",args);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONIN,"fapi::PutRing");
  }
#endif

#ifdef ECMD_STATIC_FUNCTIONS
  rc = dllFapiPutRing(i_handle, i_address, i_data);
#else
  if (fapiDllFnTable[ECMD_FAPIPUTRING] == NULL) {
     fapiDllFnTable[ECMD_FAPIPUTRING] = (void*)dlsym(dlHandle, "dllFapiPutRing");
     if (fapiDllFnTable[ECMD_FAPIPUTRING] == NULL) {
       fprintf(stderr,"dllFapiPutRing%s",ECMD_UNABLE_TO_FIND_FUNCTION_ERROR); 
       ecmdDisplayDllInfo();
       exit(ECMD_DLL_INVALID);
     }
  }

  ReturnCode (*Function)(const Target&,  const uint32_t,  ecmdDataBufferBase &) = 
      (ReturnCode(*)(const Target&,  const uint32_t,  ecmdDataBufferBase &))fapiDllFnTable[ECMD_FAPIPUTRING];
  rc =    (*Function)(i_handle, i_address, i_data);
#endif

#ifndef ECMD_STRIP_DEBUG
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &rc);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONOUT,"fapi::PutRing");
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONOUT,"ReturnCode fapi::PutRing(const Target& i_handle, const uint32_t i_address, ecmdDataBufferBase & i_data)",args);
   }
#endif

  return rc;
}
#endif

ReturnCode fapiGetScom(const Target& i_target, const uint64_t i_address, ecmdDataBufferBase & o_data) {
  ReturnCode rc;

  ecmdChipTarget   ecmdTarget;
  fapiTargetToEcmdTarget(i_target, ecmdTarget); 

#ifndef ECMD_STATIC_FUNCTIONS
  if (dlHandle == NULL) {
    fprintf(stderr,"dllGetScom%s",ECMD_DLL_NOT_LOADED_ERROR);
    exit(ECMD_DLL_INVALID);
  }
#endif

#ifndef ECMD_STRIP_DEBUG
  int myTcount;
  std::vector< void * > args;
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &ecmdTarget);
     args.push_back((void*) &i_address);
     args.push_back((void*) &o_data);
     fppCallCount++;
     myTcount = fppCallCount;
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONIN,"uint32_t getScom(ecmdChipTarget & ecmdTarget, uint64_t i_address, ecmdDataBufferBase & o_data)",args);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONIN,"getScom");
  }
#endif

   ecmdChipTarget cacheTarget;
   cacheTarget = ecmdTarget;
   ecmdSetTargetDepth(cacheTarget, ECMD_DEPTH_CHIP);
   if (ecmdIsRingCacheEnabled(cacheTarget)) return ECMD_RING_CACHE_ENABLED;
#ifdef ECMD_STATIC_FUNCTIONS
  rc = dllGetScom(ecmdTarget, i_address, o_data);
#else
  if (DllFnTable[ECMD_GETSCOM] == NULL) {
     DllFnTable[ECMD_GETSCOM] = (void*)dlsym(dlHandle, "dllGetScom");
     if (DllFnTable[ECMD_GETSCOM] == NULL) {
       fprintf(stderr,"dllGetScom%s",ECMD_UNABLE_TO_FIND_FUNCTION_ERROR); 
       ecmdDisplayDllInfo();
       exit(ECMD_DLL_INVALID);
     }
  }

  uint32_t (*Function)(ecmdChipTarget &,  uint64_t,  ecmdDataBufferBase &) = 
      (uint32_t(*)(ecmdChipTarget &,  uint64_t,  ecmdDataBufferBase &))DllFnTable[ECMD_GETSCOM];
  rc =    (*Function)(ecmdTarget, i_address, o_data);
#endif

#ifndef ECMD_STRIP_DEBUG
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &rc);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONOUT,"getScom");
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONOUT,"uint32_t getScom(ecmdChipTarget & ecmdTarget, uint64_t i_address, ecmdDataBufferBase & o_data)",args);
   }
#endif

  if (rc && !ecmdGetGlobalVar(ECMD_GLOBALVAR_QUIETERRORMODE)) {
    std::string errorString;
    errorString = ecmdGetErrorMsg(rc, false, ecmdGetGlobalVar(ECMD_GLOBALVAR_CMDLINEMODE), false);
    if (errorString.size()) ecmdOutput(errorString.c_str());
  }
  return rc;
}
ReturnCode fapiPutScom(const Target& i_target, const uint32_t i_address,  ecmdDataBufferBase & i_data) {

  ReturnCode rc;

  ecmdChipTarget   ecmdTarget;
  ecmdChipTarget * ecmdTargetPtr;
  ecmdTargetPtr = (ecmdChipTarget *) i_target.get();
  ecmdTarget = (*ecmdTargetPtr);                

/*
  ecmdDataBuffer *dummy;
  dummy = i_data.getBuff();
*/

#ifndef ECMD_STATIC_FUNCTIONS
  if (dlHandle == NULL) {
    fprintf(stderr,"dllPutScom%s",ECMD_DLL_NOT_LOADED_ERROR);
    exit(ECMD_DLL_INVALID);
  }
#endif

#ifndef ECMD_STRIP_DEBUG
  int myTcount;
  std::vector< void * > args;
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &ecmdTarget);
     args.push_back((void*) &i_address);
     args.push_back((void*) &i_data);
     fppCallCount++;
     myTcount = fppCallCount;
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONIN,"uint32_t putScom(ecmdChipTarget & ecmdTarget, uint64_t i_address, ecmdDataBufferBase & i_data)",args);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONIN,"putScom");
  }
#endif

   ecmdChipTarget cacheTarget;
   cacheTarget = ecmdTarget;
   ecmdSetTargetDepth(cacheTarget, ECMD_DEPTH_CHIP);
   if (ecmdIsRingCacheEnabled(cacheTarget)) return ECMD_RING_CACHE_ENABLED;
#ifdef ECMD_STATIC_FUNCTIONS
  rc = dllPutScom(ecmdTarget, i_address, i_data);
#else
  if (DllFnTable[ECMD_PUTSCOM] == NULL) {
     DllFnTable[ECMD_PUTSCOM] = (void*)dlsym(dlHandle, "dllPutScom");
     if (DllFnTable[ECMD_PUTSCOM] == NULL) {
       fprintf(stderr,"dllPutScom%s",ECMD_UNABLE_TO_FIND_FUNCTION_ERROR); 
       ecmdDisplayDllInfo();
       exit(ECMD_DLL_INVALID);
     }
  }

  uint32_t (*Function)(ecmdChipTarget &,  uint64_t,  ecmdDataBufferBase &) = 
      (uint32_t(*)(ecmdChipTarget &,  uint64_t,  ecmdDataBufferBase &))DllFnTable[ECMD_PUTSCOM];
  rc =    (*Function)(ecmdTarget, i_address, i_data);
#endif

#ifndef ECMD_STRIP_DEBUG
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &rc);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONOUT,"putScom");
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONOUT,"uint32_t putScom(ecmdChipTarget & ecmdTarget, uint64_t i_address, ecmdDataBufferBase & i_data)",args);
   }
#endif

  if (rc && !ecmdGetGlobalVar(ECMD_GLOBALVAR_QUIETERRORMODE)) {
    std::string errorString;
    errorString = ecmdGetErrorMsg(rc, false, ecmdGetGlobalVar(ECMD_GLOBALVAR_CMDLINEMODE), false);
    if (errorString.size()) ecmdOutput(errorString.c_str());
  }

  return rc;
}
#if 0
// re-add when ready to support this 
ReturnCode fapi::PutScomUnderMask(const Target& i_handle, /* JFDEBUG const */ uint64_t i_address, ecmdDataBufferBase & i_data, const ecmdDataBufferBase & i_mask) {

  ReturnCode rc;

#ifndef ECMD_STATIC_FUNCTIONS
  if (dlHandle == NULL) {
    fprintf(stderr,"dllPutScomUnderMask%s",ECMD_DLL_NOT_LOADED_ERROR);
    exit(ECMD_DLL_INVALID);
  }
#endif

  if (!fapiInitialized) {
    fprintf(stderr,"dllPutScomUnderMask: eCMD Extension not initialized before function called\n");
    fprintf(stderr,"dllPutScomUnderMask: OR eCMD fapi Extension not supported by plugin\n");
    exit(ECMD_DLL_INVALID);
  }

#ifndef ECMD_STRIP_DEBUG
  int myTcount;
  std::vector< void * > args;
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &i_handle);
     args.push_back((void*) &i_address);
     args.push_back((void*) &i_data);
     args.push_back((void*) &i_mask);
     fppCallCount++;
     myTcount = fppCallCount;
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONIN,"ReturnCode fapi::PutScomUnderMask(const Target& i_handle, /* JFDEBUG const */ uint64_t i_address, /* JFDEBUG const */DataBuffer & i_data, const DataBuffer & i_mask)",args);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONIN,"fapi::PutScomUnderMask");
  }
#endif

#ifdef ECMD_STATIC_FUNCTIONS
  rc = dllPutScomUnderMask(i_handle, i_address, i_data, i_mask);
#else
  if (DllFnTable[ECMD_PUTSCOMUNDERMASK] == NULL) {
     DllFnTable[ECMD_PUTSCOMUNDERMASK] = (void*)dlsym(dlHandle, "dllPutScomUnderMask");
     if (DllFnTable[ECMD_PUTSCOMUNDERMASK] == NULL) {
       fprintf(stderr,"dllPutScomUnderMask%s",ECMD_UNABLE_TO_FIND_FUNCTION_ERROR); 
       ecmdDisplayDllInfo();
       exit(ECMD_DLL_INVALID);
     }
  }

  ReturnCode (*Function)(const Target&,  /* JFDEBUG const */ uint64_t,  ecmdDataBufferBase &,  const ecmdDataBufferBase &) = 
      (ReturnCode(*)(const Target&,  /* JFDEBUG const */ uint64_t,  ecmdDataBufferBase &,  const ecmdDataBufferBase &))DllFnTable[ECMD_PUTSCOMUNDERMASK];
  rc =    (*Function)(i_handle, i_address, i_data, i_mask);
#endif

#ifndef ECMD_STRIP_DEBUG
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &rc);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONOUT,"fapi::PutScomUnderMask");
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONOUT,"ReturnCode fapi::PutScomUnderMask(const Target& i_handle, /* JFDEBUG const */ uint64_t i_address, /* JFDEBUG const */DataBuffer & i_data, const DataBuffer & i_mask)",args);
   }
#endif

  return rc;
}

#endif

ReturnCode fapiGetCfamRegister(const Target& i_target, const uint32_t i_address, ecmdDataBufferBase & o_data){

  ReturnCode rc; 

  ecmdChipTarget   ecmdTarget;
  ecmdChipTarget * ecmdTargetPtr;
  ecmdTargetPtr = (ecmdChipTarget *) i_target.get();
  ecmdTarget = (*ecmdTargetPtr);                

#ifndef ECMD_STATIC_FUNCTIONS
  if (dlHandle == NULL) {
    fprintf(stderr,"dllGetCfamRegister%s",ECMD_DLL_NOT_LOADED_ERROR);
    exit(ECMD_DLL_INVALID);
  }
#endif

#ifndef ECMD_STRIP_DEBUG
  int myTcount;
  std::vector< void * > args;
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &ecmdTarget);
     args.push_back((void*) &i_address);
     args.push_back((void*) &o_data);
     fppCallCount++;
     myTcount = fppCallCount;
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONIN,"uint32_t getCfamRegister(ecmdChipTarget & ecmdTarget, uint32_t i_address, ecmdDataBufferBase & o_data)",args);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONIN,"getCfamRegister");
  }
#endif

   ecmdChipTarget cacheTarget;
   cacheTarget = ecmdTarget;
   ecmdSetTargetDepth(cacheTarget, ECMD_DEPTH_CHIP);
   if (ecmdIsRingCacheEnabled(cacheTarget)) return ECMD_RING_CACHE_ENABLED;
#ifdef ECMD_STATIC_FUNCTIONS
  rc = dllGetCfamRegister(ecmdTarget, i_address, o_data);
#else
  if (DllFnTable[ECMD_GETCFAMREGISTER] == NULL) {
     DllFnTable[ECMD_GETCFAMREGISTER] = (void*)dlsym(dlHandle, "dllGetCfamRegister");
     if (DllFnTable[ECMD_GETCFAMREGISTER] == NULL) {
       fprintf(stderr,"dllGetCfamRegister%s",ECMD_UNABLE_TO_FIND_FUNCTION_ERROR); 
       ecmdDisplayDllInfo();
       exit(ECMD_DLL_INVALID);
     }
  }

  uint32_t (*Function)(ecmdChipTarget &,  uint32_t,  ecmdDataBufferBase &) = 
      (uint32_t(*)(ecmdChipTarget &,  uint32_t,  ecmdDataBufferBase &))DllFnTable[ECMD_GETCFAMREGISTER];
  rc =    (*Function)(ecmdTarget, i_address, o_data);
#endif

#ifndef ECMD_STRIP_DEBUG
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &rc);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONOUT,"getCfamRegister");
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONOUT,"uint32_t getCfamRegister(ecmdChipTarget & ecmdTarget, uint32_t i_address, ecmdDataBufferBase & o_data)",args);
   }
#endif

  if (rc && !ecmdGetGlobalVar(ECMD_GLOBALVAR_QUIETERRORMODE)) {
    std::string errorString;
    errorString = ecmdGetErrorMsg(rc, false, ecmdGetGlobalVar(ECMD_GLOBALVAR_CMDLINEMODE), false);
    if (errorString.size()) ecmdOutput(errorString.c_str());
  }

  return rc;
}


ReturnCode fapiPutCfamRegister(const Target& i_target, const uint32_t i_address, ecmdDataBufferBase & i_data){

  ReturnCode rc;
  
  ecmdChipTarget   ecmdTarget;
  ecmdChipTarget * ecmdTargetPtr;
  ecmdTargetPtr = (ecmdChipTarget *) i_target.get();
  ecmdTarget = (*ecmdTargetPtr);                

#ifndef ECMD_STATIC_FUNCTIONS
  if (dlHandle == NULL) {
    fprintf(stderr,"dllPutCfamRegister%s",ECMD_DLL_NOT_LOADED_ERROR);
    exit(ECMD_DLL_INVALID);
  }
#endif

#ifndef ECMD_STRIP_DEBUG
  int myTcount;
  std::vector< void * > args;
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &ecmdTarget);
     args.push_back((void*) &i_address);
     args.push_back((void*) &i_data);
     fppCallCount++;
     myTcount = fppCallCount;
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONIN,"uint32_t putCfamRegister(ecmdChipTarget & ecmdTarget, uint32_t i_address, ecmdDataBuffer & i_data)",args);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONIN,"putCfamRegister");
  }
#endif

   ecmdChipTarget cacheTarget;
   cacheTarget = ecmdTarget;
   ecmdSetTargetDepth(cacheTarget, ECMD_DEPTH_CHIP);
   if (ecmdIsRingCacheEnabled(cacheTarget)) return ECMD_RING_CACHE_ENABLED;
#ifdef ECMD_STATIC_FUNCTIONS
  rc = dllPutCfamRegister(ecmdTarget, i_address, i_data);
#else
  if (DllFnTable[ECMD_PUTCFAMREGISTER] == NULL) {
     DllFnTable[ECMD_PUTCFAMREGISTER] = (void*)dlsym(dlHandle, "dllPutCfamRegister");
     if (DllFnTable[ECMD_PUTCFAMREGISTER] == NULL) {
       fprintf(stderr,"dllPutCfamRegister%s",ECMD_UNABLE_TO_FIND_FUNCTION_ERROR); 
       ecmdDisplayDllInfo();
       exit(ECMD_DLL_INVALID);
     }
  }

  uint32_t (*Function)(ecmdChipTarget &,  uint32_t,  ecmdDataBufferBase &) = 
      (uint32_t(*)(ecmdChipTarget &,  uint32_t,  ecmdDataBufferBase &))DllFnTable[ECMD_PUTCFAMREGISTER];
  rc =    (*Function)(ecmdTarget, i_address, i_data);
#endif

#ifndef ECMD_STRIP_DEBUG
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &rc);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONOUT,"putCfamRegister");
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONOUT,"uint32_t putCfamRegister(ecmdChipTarget & ecmdTarget, uint32_t i_address, ecmdDataBuffer & i_data)",args);
   }
#endif

  if (rc && !ecmdGetGlobalVar(ECMD_GLOBALVAR_QUIETERRORMODE)) {
    std::string errorString;
    errorString = ecmdGetErrorMsg(rc, false, ecmdGetGlobalVar(ECMD_GLOBALVAR_CMDLINEMODE), false);
    if (errorString.size()) ecmdOutput(errorString.c_str());
  }

  return rc;
}


