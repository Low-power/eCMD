/* The following has been auto-generated by makedll.pl */

#include <stdio.h>

#include <ecmdClientCapi.H>
#include <ecmdSharedUtils.H>
#include <fapiClientCapi.H>
#include <fapiHwAccess.H> 
#ifndef ECMD_STATIC_FUNCTIONS
#include <fapiClientEnums.H>
#include <fapiTarget.H>
#endif

#include <ecmdUtils.H>

static const char ECMD_DLL_NOT_LOADED_ERROR[] = ": eCMD Function called before DLL has been loaded\n";
static const char ECMD_UNABLE_TO_FIND_FUNCTION_ERROR[] = ": Unable to find function, must be an invalid DLL - program aborting\n";

using namespace fapi;

#ifndef ECMD_STATIC_FUNCTIONS

 #include <dlfcn.h>

/* This is from ecmdClientCapiFunc.C */
 extern void * dlHandle;
 void * fapiDllFnTable[FAPI_NUMFUNCTIONS];

#else

 #include <fapiDllCapi.H>

#endif


/* Our initialization flag */
 bool fapiInitialized = false;
#ifndef ECMD_STRIP_DEBUG
extern int ecmdClientDebug;
extern int fppCallCount;
extern bool ecmdDebugOutput;
#endif


ReturnCode fapiGetRing(const Target& i_handle, const uint32_t i_address, ecmdDataBufferBase & o_data) {

  ReturnCode rc;

#ifndef ECMD_STATIC_FUNCTIONS
  if (dlHandle == NULL) {
    fprintf(stderr,"dllFapiGetRing%s",ECMD_DLL_NOT_LOADED_ERROR);
    exit(ECMD_DLL_INVALID);
  }
#endif

  if (!fapiInitialized) {
    fprintf(stderr,"dllFapiGetRing: eCMD Extension not initialized before function called\n");
    fprintf(stderr,"dllFapiGetRing: OR eCMD fapi Extension not supported by plugin\n");
    exit(ECMD_DLL_INVALID);
  }

#ifndef ECMD_STRIP_DEBUG
  int myTcount;
  std::vector< void * > args;
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &i_handle);
     args.push_back((void*) &i_address);
     args.push_back((void*) &o_data);
     fppCallCount++;
     myTcount = fppCallCount;
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONIN,"ReturnCode fapi::GetRing(const Target& i_handle, const uint32_t i_address, ecmdDataBufferBase & o_data)",args);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONIN,"fapi::GetRing");
  }
#endif

#ifdef ECMD_STATIC_FUNCTIONS
  rc = dllFapiGetRing(i_handle, i_address, o_data);
#else
  if (fapiDllFnTable[ECMD_FAPIGETRING] == NULL) {
     fapiDllFnTable[ECMD_FAPIGETRING] = (void*)dlsym(dlHandle, "dllFapiGetRing");
     if (fapiDllFnTable[ECMD_FAPIGETRING] == NULL) {
       fprintf(stderr,"dllFapiGetRing%s",ECMD_UNABLE_TO_FIND_FUNCTION_ERROR); 
       ecmdDisplayDllInfo();
       exit(ECMD_DLL_INVALID);
     }
  }

  ReturnCode (*Function)(const Target&,  const uint32_t,  ecmdDataBufferBase &) = 
      (ReturnCode(*)(const Target&,  const uint32_t,  ecmdDataBufferBase &))fapiDllFnTable[ECMD_FAPIGETRING];
  rc =    (*Function)(i_handle, i_address, o_data);
#endif

#ifndef ECMD_STRIP_DEBUG
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &rc);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONOUT,"fapi::GetRing");
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONOUT,"ReturnCode fapi::GetRing(const Target& i_handle, const uint32_t i_address, ecmdDataBufferBase & o_data)",args);
   }
#endif

  return rc;
}

ReturnCode fapiPutRing(const Target& i_handle, const uint32_t i_address, ecmdDataBufferBase & i_data) {

  ReturnCode rc;

#ifndef ECMD_STATIC_FUNCTIONS
  if (dlHandle == NULL) {
    fprintf(stderr,"dllFapiPutRing%s",ECMD_DLL_NOT_LOADED_ERROR);
    exit(ECMD_DLL_INVALID);
  }
#endif

  if (!fapiInitialized) {
    fprintf(stderr,"dllFapiPutRing: eCMD Extension not initialized before function called\n");
    fprintf(stderr,"dllFapiPutRing: OR eCMD fapi Extension not supported by plugin\n");
    exit(ECMD_DLL_INVALID);
  }

#ifndef ECMD_STRIP_DEBUG
  int myTcount;
  std::vector< void * > args;
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &i_handle);
     args.push_back((void*) &i_address);
     args.push_back((void*) &i_data);
     fppCallCount++;
     myTcount = fppCallCount;
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONIN,"ReturnCode fapi::PutRing(const Target& i_handle, const uint32_t i_address, ecmdDataBufferBase & i_data)",args);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONIN,"fapi::PutRing");
  }
#endif

#ifdef ECMD_STATIC_FUNCTIONS
  rc = dllFapiPutRing(i_handle, i_address, i_data);
#else
  if (fapiDllFnTable[ECMD_FAPIPUTRING] == NULL) {
     fapiDllFnTable[ECMD_FAPIPUTRING] = (void*)dlsym(dlHandle, "dllFapiPutRing");
     if (fapiDllFnTable[ECMD_FAPIPUTRING] == NULL) {
       fprintf(stderr,"dllFapiPutRing%s",ECMD_UNABLE_TO_FIND_FUNCTION_ERROR); 
       ecmdDisplayDllInfo();
       exit(ECMD_DLL_INVALID);
     }
  }

  ReturnCode (*Function)(const Target&,  const uint32_t,  ecmdDataBufferBase &) = 
      (ReturnCode(*)(const Target&,  const uint32_t,  ecmdDataBufferBase &))fapiDllFnTable[ECMD_FAPIPUTRING];
  rc =    (*Function)(i_handle, i_address, i_data);
#endif

#ifndef ECMD_STRIP_DEBUG
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &rc);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONOUT,"fapi::PutRing");
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONOUT,"ReturnCode fapi::PutRing(const Target& i_handle, const uint32_t i_address, ecmdDataBufferBase & i_data)",args);
   }
#endif

  return rc;
}

