/* The following has been auto-generated by makedll.pl */

#include <stdio.h>

#include <ecmdClientCapi.H>
#include <ecmdSharedUtils.H>
#include <fapiClientCapi.H>
#include <fapiSystemConfig.H>
#ifndef ECMD_STATIC_FUNCTIONS
#include <fapiClientEnums.H>
#include <fapiTarget.H>
#endif

#include <ecmdUtils.H>

static const char ECMD_DLL_NOT_LOADED_ERROR[] = ": eCMD Function called before DLL has been loaded\n";
static const char ECMD_UNABLE_TO_FIND_FUNCTION_ERROR[] = ": Unable to find function, must be an invalid DLL - program aborting\n";

using namespace fapi;

#ifndef ECMD_STATIC_FUNCTIONS

 #include <dlfcn.h>

/* This is from ecmdClientCapiFunc.C */
 extern void * dlHandle;
 extern void * fapiDllFnTable[FAPI_NUMFUNCTIONS];
 extern bool fapiInitialized; 
#else

 #include <fapiDllCapi.H>

#endif


/* Our initialization flag */
 bool fapiInitialized = false;
#ifndef ECMD_STRIP_DEBUG
extern int ecmdClientDebug;
extern int fppCallCount;
extern bool ecmdDebugOutput;
#endif

fapi::ReturnCode fapiGetFunctionalChiplets(const fapi::Target & i_target, const fapi::TargetType i_chipletType, std::vector<fapi::Target> & o_chiplets) {

  ReturnCode rc;

#ifndef ECMD_STATIC_FUNCTIONS
  if (dlHandle == NULL) {
    fprintf(stderr,"dllFapiGetFunctionalChiplets%s",ECMD_DLL_NOT_LOADED_ERROR);
    exit(ECMD_DLL_INVALID);
  }
#endif

  if (!fapiInitialized) {
    fprintf(stderr,"dllFapiGetFunctionalChiplets: eCMD Extension not initialized before function called\n");
    fprintf(stderr,"dllFapiGetFunctionalChiplets: OR eCMD fapi Extension not supported by plugin\n");
    exit(ECMD_DLL_INVALID);
  }

#ifndef ECMD_STRIP_DEBUG
  int myTcount;
  std::vector< void * > args;
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &i_target);
     args.push_back((void*) &i_chipletType);
     args.push_back((void*) &o_chiplets);
     fppCallCount++;
     myTcount = fppCallCount;
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONIN,"ReturnCode fapiGetFunctionalChiplets(const Target& i_target, const TargetType & i_chipletType, std::vector<Target> & o_chiplets)",args);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONIN,"fapiGetFunctionalChiplets");
  }
#endif

#ifdef ECMD_STATIC_FUNCTIONS
  rc = dllFapiGetFunctionalChiplets(i_target, i_chipletType, o_chiplets);
#else
  if (fapiDllFnTable[ECMD_FAPIGETFUNCTIONALCHIPLETS] == NULL) {
     fapiDllFnTable[ECMD_FAPIGETFUNCTIONALCHIPLETS] = (void*)dlsym(dlHandle, "dllFapiGetFunctionalChiplets");
     if (fapiDllFnTable[ECMD_FAPIGETFUNCTIONALCHIPLETS] == NULL) {
       fprintf(stderr,"dllFapiGetFunctionalChiplets%s",ECMD_UNABLE_TO_FIND_FUNCTION_ERROR); 
       ecmdDisplayDllInfo();
       exit(ECMD_DLL_INVALID);
     }
  }

  ReturnCode (*Function)(const Target&,  const TargetType ,  std::vector<Target> &) = 
      (ReturnCode(*)(const Target&,  const TargetType,  std::vector<Target> &))fapiDllFnTable[ECMD_FAPIGETFUNCTIONALCHIPLETS];
  rc =    (*Function)(i_target, i_chipletType, o_chiplets);
#endif

#ifndef ECMD_STRIP_DEBUG
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &rc);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONOUT,"fapiGetFunctionalChiplets");
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONOUT,"ReturnCode fapiGetFunctionalChiplets(const Target& i_handle, const TargetType & i_chiplet, std::vector<Target> & o_entries)",args);
   }
#endif

  return rc;
}

ReturnCode fapiGetExistingChiplets(const Target& i_handle, const TargetType  i_chiplet, std::vector<Target> &o_entries) {

  ReturnCode rc;

#ifndef ECMD_STATIC_FUNCTIONS
  if (dlHandle == NULL) {
    fprintf(stderr,"dllFapiGetExistingChiplets%s",ECMD_DLL_NOT_LOADED_ERROR);
    exit(ECMD_DLL_INVALID);
  }
#endif

  if (!fapiInitialized) {
    fprintf(stderr,"dllFapiGetExistingChiplets: eCMD Extension not initialized before function called\n");
    fprintf(stderr,"dllFapiGetExistingChiplets: OR eCMD fapi Extension not supported by plugin\n");
    exit(ECMD_DLL_INVALID);
  }

#ifndef ECMD_STRIP_DEBUG
  int myTcount;
  std::vector< void * > args;
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &i_handle);
     args.push_back((void*) &i_chiplet);
     args.push_back((void*) &o_entries);
     fppCallCount++;
     myTcount = fppCallCount;
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONIN,"ReturnCode fapiGetExistingChiplets(const Target& i_handle, const TargetType & i_chiplet, std::vector<Target> &o_entries)",args);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONIN,"fapiGetExistingChiplets");
  }
#endif

#ifdef ECMD_STATIC_FUNCTIONS
  rc = dllFapiGetExistingChiplets(i_handle, i_chiplet, o_entries);
#else
  if (fapiDllFnTable[ECMD_FAPIGETEXISTINGCHIPLETS] == NULL) {
     fapiDllFnTable[ECMD_FAPIGETEXISTINGCHIPLETS] = (void*)dlsym(dlHandle, "dllFapiGetExistingChiplets");
     if (fapiDllFnTable[ECMD_FAPIGETEXISTINGCHIPLETS] == NULL) {
       fprintf(stderr,"dllFapiGetExistingChiplets%s",ECMD_UNABLE_TO_FIND_FUNCTION_ERROR); 
       ecmdDisplayDllInfo();
       exit(ECMD_DLL_INVALID);
     }
  }

  ReturnCode (*Function)(const Target&,  const TargetType,  std::vector<Target> &) = 
      (ReturnCode(*)(const Target&,  const TargetType,  std::vector<Target> &))fapiDllFnTable[ECMD_FAPIGETEXISTINGCHIPLETS];
  rc =    (*Function)(i_handle, i_chiplet, o_entries);
#endif

#ifndef ECMD_STRIP_DEBUG
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &rc);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONOUT,"fapiGetExistingChiplets");
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONOUT,"ReturnCode fapiGetExistingChiplets(const Target& i_handle, const TargetType & i_chiplet, std::vector<Target> &o_entries)",args);
   }
#endif

  return rc;
}

fapi::ReturnCode fapiGetFunctionalDimms(const fapi::Target & i_target, std::vector<fapi::Target> & o_dimms) {

  ReturnCode rc;

#ifndef ECMD_STATIC_FUNCTIONS
  if (dlHandle == NULL) {
    fprintf(stderr,"dllFapiGetFunctionalDimms%s",ECMD_DLL_NOT_LOADED_ERROR);
    exit(ECMD_DLL_INVALID);
  }
#endif

  if (!fapiInitialized) {
    fprintf(stderr,"dllFapiGetFunctionalDimms: eCMD Extension not initialized before function called\n");
    fprintf(stderr,"dllFapiGetFunctionalDimms: OR eCMD fapi Extension not supported by plugin\n");
    exit(ECMD_DLL_INVALID);
  }

#ifndef ECMD_STRIP_DEBUG
  int myTcount;
  std::vector< void * > args;
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &i_target);
     args.push_back((void*) &o_dimms);
     fppCallCount++;
     myTcount = fppCallCount;
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONIN,"ReturnCode fapiGetFunctionalDimms(const Target&  std::vector<Target> & o_dimms)",args);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONIN,"fapiGetFunctionalDimms");
  }
#endif

#ifdef ECMD_STATIC_FUNCTIONS
  rc = dllFapiGetFunctionalDimms(i_target, o_dimms);
#else
  if (fapiDllFnTable[ECMD_FAPIGETFUNCTIONALDIMMS] == NULL) {
     fapiDllFnTable[ECMD_FAPIGETFUNCTIONALDIMMS] = (void*)dlsym(dlHandle, "dllFapiGetFunctionalDimms");
     if (fapiDllFnTable[ECMD_FAPIGETFUNCTIONALDIMMS] == NULL) {
       fprintf(stderr,"dllFapiGetFunctionalDimms%s",ECMD_UNABLE_TO_FIND_FUNCTION_ERROR); 
       ecmdDisplayDllInfo();
       exit(ECMD_DLL_INVALID);
     }
  }

  ReturnCode (*Function)(const Target&,  std::vector<Target> &) = 
      (ReturnCode(*)(const Target&,  std::vector<Target> &))fapiDllFnTable[ECMD_FAPIGETFUNCTIONALDIMMS];
  rc =    (*Function)(i_target, o_dimms);
#endif

#ifndef ECMD_STRIP_DEBUG
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &rc);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONOUT,"fapiGetFunctionalDimms");
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONOUT,"ReturnCode fapiGetFunctionalDimms(const Target& i_handle, const TargetType & i_dimms, std::vector<Target> & o_entries)",args);
   }
#endif

  return rc;
}


fapi::ReturnCode fapiGetExistingDimms(const fapi::Target & i_target, std::vector<fapi::Target> & o_dimms) {

  ReturnCode rc;

#ifndef ECMD_STATIC_FUNCTIONS
  if (dlHandle == NULL) {
    fprintf(stderr,"dllFapiGetExistingDimms%s",ECMD_DLL_NOT_LOADED_ERROR);
    exit(ECMD_DLL_INVALID);
  }
#endif

  if (!fapiInitialized) {
    fprintf(stderr,"dllFapiGetExistingDimms: eCMD Extension not initialized before function called\n");
    fprintf(stderr,"dllFapiGetExistingDimms: OR eCMD fapi Extension not supported by plugin\n");
    exit(ECMD_DLL_INVALID);
  }

#ifndef ECMD_STRIP_DEBUG
  int myTcount;
  std::vector< void * > args;
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &i_target);
     args.push_back((void*) &o_dimms);
     fppCallCount++;
     myTcount = fppCallCount;
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONIN,"ReturnCode fapiGetExistingDimms(const Target&  std::vector<Target> & o_dimms)",args);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONIN,"fapiGetExistingDimms");
  }
#endif

#ifdef ECMD_STATIC_FUNCTIONS
  rc = dllFapiGetExistingDimms(i_target, o_dimms);
#else
  if (fapiDllFnTable[ECMD_FAPIGETEXISTINGDIMMS] == NULL) {
     fapiDllFnTable[ECMD_FAPIGETEXISTINGDIMMS] = (void*)dlsym(dlHandle, "dllFapiGetExistingDimms");
     if (fapiDllFnTable[ECMD_FAPIGETEXISTINGDIMMS] == NULL) {
       fprintf(stderr,"dllFapiGetExistingDimms%s",ECMD_UNABLE_TO_FIND_FUNCTION_ERROR); 
       ecmdDisplayDllInfo();
       exit(ECMD_DLL_INVALID);
     }
  }

  ReturnCode (*Function)(const Target&,  std::vector<Target> &) = 
      (ReturnCode(*)(const Target&,  std::vector<Target> &))fapiDllFnTable[ECMD_FAPIGETEXISTINGDIMMS];
  rc =    (*Function)(i_target, o_dimms);
#endif

#ifndef ECMD_STRIP_DEBUG
  if (ecmdClientDebug != 0) {
     args.push_back((void*) &rc);
     ecmdFunctionTimer(myTcount,ECMD_TMR_FUNCTIONOUT,"fapiGetExistingDimms");
     ecmdFunctionParmPrinter(myTcount,ECMD_FPP_FUNCTIONOUT,"ReturnCode fapiGetExistingDimms(const Target& i_handle, const TargetType & i_dimms, std::vector<Target> & o_entries)",args);
   }
#endif

  return rc;
}

/* The previous has been auto-generated by makedll.pl */
